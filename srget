#!/usr/bin/env python

import urlparse
import os
import sys
import socket as c_sock
import asyncore
import logging
import pickle
#from cStringIO import StringIO



output_file = None
option_c = False
numConn = 5
dest_in = None
path = '/'
port = 80

# Asyncore loop
def make_request(req_type, what, details, version="1.1"):
    """ Compose an HTTP request """
    NL = "\r\n"
    request_line = "{req_type} {what} HTTP/{ver}".format(
        req_type=req_type,
        what=what,
        ver=version
    )

    detail_lines = NL.join(
        "{}: {}".format(name, value) for name, value in details
    )

    full_request = request_line + NL + detail_lines + NL + NL
    return full_request

class HTTPClient(asyncore.dispatcher):
    def __init__(self, host, path,portIn, start_byte,end_byte, checked_date,output_file):
        asyncore.dispatcher.__init__(self)
        self.create_socket(c_sock.AF_INET, c_sock.SOCK_STREAM)
        self.connect((host, portIn))
        self.host = host
        self.recvbuf = ""
        self.logger = logging.getLogger(host+path)
        self.current_byte = start_byte
        self.output_file = output_file
        self.output_file.seek(start_byte)
        self.header = ""
        self.wait_for_header = True

        self.sendbuf = ""
        ## make my request
        self.write(
            make_request('GET', path,
            [("host", host),
             ("Range", "bytes={start}-{end}".format(start=start_byte,end =end_byte)),
             ("If-Range", checked_date),
             ("Connection", "close")])
        )

    def write(self, msg):
        self.sendbuf += msg

    def handle_connect(self):
        self.logger.debug("connection established")

    def handle_close(self):
        self.logger.debug("got disconnected")
        self.close()

    def handle_read(self):
        buf = self.recv(8192)
        self.output_file.seek(self.current_byte)

        if self.wait_for_header and ('\r\n\r\n' in self.header or '\r\n\r\n' in buf):
            self.wait_for_header = False
            data_wo_header = buf[buf.find('\r\n\r\n')+4:]
            self.output_file.write(data_wo_header)
            self.current_byte += len(data_wo_header)
        elif self.wait_for_header:
            self.header += buf
        else:
            self.output_file.write(buf)
            self.current_byte += len(buf)


        #self.recvbuf.write(buf)

        self.logger.debug("recv {0} bytes".format(len(buf)))

    def writeable(self):
        return len(self.sendbuf) > 0

    def handle_write(self):
        bytes_sent = self.send(self.sendbuf)
        self.sendbuf = self.sendbuf[bytes_sent:]

# get byte from gap
def byte_from_gap(lst):
    returned_list = []
    for gap in lst:
        returned_list.append("bytes={s}-{e]").format(s=gap[0],e=gap[1])
    return returned_list

# Set byte range
def cut_content(content,connection_number):
    returned_list = []
    connection_number = int(connection_number)
    start_point = 0
    one_size = content/connection_number
    while connection_number > 1:
        end_point = start_point + one_size-1
        returned_list += [(start_point,end_point)]
        start_point += one_size
        connection_number -= 1
    returned_list += [(start_point,content-1)]

    return returned_list

# Organize address and port for connection
def setAddress(addIn):
    fullAddress = urlparse.urlparse(addIn)
    if (fullAddress.netloc).find(":") != -1:
        dest = fullAddress.netloc[:(fullAddress.netloc).find(":")]
    else:
        dest = fullAddress.netloc
    if fullAddress.port != None:
        port = fullAddress.port
    else:
        port = 80
    path = fullAddress.path

    return fullAddress,dest,port,path


def getSize(fileobject):
    with open(fileobject,'rb') as f:
        f.seek(0,2)        # move the cursor to the end of the file
        return f.tell()
    
def getHeadRequest(serv, objName):
    return ("HEAD {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n\r\n").format(o=objName, s=serv)


def getHeadRangeRequest(serv,objName,start_pos,end_pos,tag):
    return ("HEAD {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n"+
        "If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)   

def mkDownloadRequest(serv, objName):
    return ("GET {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n\r\n").format(o=objName, s=serv)

def mkResumReqModified(serv,objName,start_pos,end_pos,tag):
    return ("GET {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n"+
        "If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)
    

def split_header(out_file):
    header_dict = dict()
    with open(out_file,'rb') as h:
        all_data = h.read()        
    header_list = all_data.split("\r\n")
    for each in header_list[1:-2]:
        current_element = each.split(": ")
        header_dict[current_element[0]] = current_element[1]
    return header_dict    

def get_head_range(servName,portIn,reqHead,output_head):
    head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
    head_sock.connect((servName,portIn))

    head_sock.send(reqHead)
    data = ""

    while True:
        current = head_sock.recv(1024000)
        data+=current
        if data[-4:] == "\r\n\r\n":
            
            head_sock.close()
            break


    return sys.getsizeof(data)

def get_head(servName,portIn,reqHead,output_head):
    head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)

    head_sock.connect((servName,portIn))

    head_sock.send(reqHead)
    data = ""
    with open(output_head,'wb') as h:
        while True:
            current = head_sock.recv(1024000)
            h.write(current)
            data+=current
            if data[-4:] == "\r\n\r\n":    
                head_sock.close()
                break
    return sys.getsizeof(data)

def resume_connect(servName,portIn,start_byte,end_byte,path,version_reference,output_file):
    # get size of head in this request
    reqHead = getHeadRangeRequest(servName,path,start_byte,end_byte,version_reference)
    head_range_length = get_head_range(servName,portIn,reqHead,output_file+'.head')


    reqResume = mkResumReqModified(servName,path,start_byte,end_byte,version_reference)
    # make socket connection
    sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
    sock.connect((servName,portIn))
    sock.send(reqResume)
    with open(output_file,'rb') as rf:
        data_stream = rf.read()
    head = ""
    with open('temp','wb') as f:

        while True:
            head = sock.recv(1024)
            data_stream+=head
            f.write(head)
            if('\r\n\r\n' in data_stream):
                break

    with open('temp','rb') as rf:
        data = rf.read()
    os.remove('temp')
    with open(output_file,'ab') as f:
        f.write(data[data.find("\r\n\r\n")+4:])
        while True:
            current = sock.recv(1024000)
            f.write(current)
            data_stream+=current
            if sys.getsizeof(data_stream) == end_byte+1+head_range_length:
                sock.close()
                break




def connect(servName,portIn,startByte,path,output_file):

    # get content length from header
    reqHead = getHeadRequest(servName,path)
    header_length = get_head(servName,portIn,reqHead,output_file+'.head')
    header_content = split_header(output_file+".head")

    content_length = long(header_content['Content-Length'])

    request = mkDownloadRequest(servName,path)
    sock = c_sock.socket(c_sock.AF_INET, c_sock.SOCK_STREAM)
    sock.connect((servName,portIn))



    sock.send(request)
    data = ""
    with open(output_file,'wb') as f:

        while True:
            current = sock.recv(1024)
            f.write(current)
            data += current
            if('\r\n\r\n' in data):
                break
    with open(output_file,'rb') as rf:
        data = rf.read()
    
    with open(output_file,'wb') as f:
        f.write(data[data.find("\r\n\r\n")+4:])

        while True:
            current = sock.recv(1024000)
            f.write(current)
            data += current
            if sys.getsizeof(data) == content_length + header_length:
                sock.close()
                break
            
def new_download():
    addr,dest,port,path = setAddress(dest_in)
    # Check the scheme
    if addr.scheme == 'http':
        connect(dest,port,0,path,output_file+'.dwnld')
        os.rename(output_file+'.dwnld',output_file)
        os.remove(output_file+'.dwnld.head')
    else:
        print "Wrong format"


def basic_download():
    if (not (os.path.exists(output_file))) and (not (os.path.exists(output_file+'.dwnld'))):
        try:
            new_download() 
        except:
            print "Connection error"   
    else:
        if not (os.path.exists(output_file)):
            try:
                addr,dest,port,path = setAddress(dest_in)
                is_ETag = False
                is_Date = False
                header_dict = split_header(output_file+".dwnld.head")
                total_content_length = int(header_dict["Content-Length"])


                try:
                    ETag = header_dict["ETag"]
                    is_ETag = True
                
                except:
                    try:
                        date_modified = header_dict["Last-Modified"]
                        is_Date = True
                    except:
                        is_Date = False

                if is_ETag or is_Date:
                    file_size = getSize(output_file+".dwnld")
                    # check that modified or not
                    head_req = getHeadRequest(dest,path)
                    get_head(dest,port,head_req,output_file+'_new.head')
                    new_header_content = split_header(output_file+"_new.head")
                    os.remove(output_file+"_new.head")
                    if is_ETag:
                        if new_header_content["ETag"] != ETag:
                            print "Your file has been modified, starting new download"
                            new_download()
                        
                        else:
                            resume_connect(dest,port,file_size,total_content_length-1,path,ETag,output_file+'.dwnld')
                            os.rename(output_file+'.dwnld',output_file)
                            os.remove(output_file+'.dwnld.head')

                    else:
                        if new_header_content["Last-Modified"] != date_modified:
                            print "Your file has been modified, starting new download"
                            new_download()
                        else:
                            resume_connect(dest,port,file_size,total_content_length-1,path,date_modified,output_file+'.dwnld')
                            os.rename(output_file+'.dwnld',output_file)
                            os.remove(output_file+'.dwnld.head')

                else:
                    print "Your file cannot be resume. Start new downloading"
                    new_download()
            except:
                print "Connection error"
        else:
            print "File already existed"


# for multiple connection
def multi_download(connection_number):
    if (not (os.path.exists(output_file))) and (not (os.path.exists(output_file+'.dwnld'))):
    #try:
        is_ETag = False
        is_Date = False
        # 
        addr,dest,port,path = setAddress(dest_in)

        # get content_length + save header
        reqHead = getHeadRequest(dest,path)
        print "reqHead"
        header_length = get_head(dest,port,reqHead,output_file+'.head')
        print "header_length"
        header_content = split_header(output_file+".head")
        content_length = long(header_content['Content-Length'])

        try:
            checked_date = header_dict["ETag"]
            is_ETag = True
        
        except:
            try:
                checked_date = header_dict["Last-Modified"]
                is_Date = True
            except:
                checked_date = None

# def __init__(self, host, path,portIn, start_byte,end_byte, checked_date,content_length,output_file):

        # set each connection's range
        connection_byte_range = cut_content(content_length,connection_number) 

        # set up clients
        clients = []
        open_outfile = open(output_file,'wb')
        open_outfile.write(" "*content_length)
        for each_part in connection_byte_range:
            #string_byte = "bytes={start}-{end}".format(start=each_part[0],end =each_part[1])
            clients += [HTTPClient(dest,path,port,each_part[0],each_part[1],checked_date,open_outfile)]

        print "Before loop"
        logging.basicConfig(level=logging.DEBUG,
        format="%(asctime)-15s %(name)s: %(message)s")
        try:
            asyncore.loop()
        except:

            picle_dict = {}
            

            with open(output_file+'.pickle','wb') as h:
                pickle.dump()


    #except:
    else:
        if not (os.path.exists(output_file)):
            try:
                addr,dest,port,path = setAddress(dest_in)
                is_ETag = False
                is_Date = False
                header_dict = split_header(output_file+".dwnld.head")
                total_content_length = int(header_dict["Content-Length"])


                try:
                    ETag = header_dict["ETag"]
                    is_ETag = True
                
                except:
                    try:
                        date_modified = header_dict["Last-Modified"]
                        is_Date = True
                    except:
                        is_Date = False

                if is_ETag or is_Date:
                    file_size = getSize(output_file+".dwnld")
                    # check that modified or not
                    head_req = getHeadRequest(dest,path)
                    get_head(dest,port,head_req,output_file+'_new.head')
                    new_header_content = split_header(output_file+"_new.head")
                    os.remove(output_file+"_new.head")
                    if is_ETag:
                        if new_header_content["ETag"] != ETag:
                            print "Your file has been modified, starting new download"
                            new_download()
                        
                        else:
                            resume_connect(dest,port,file_size,total_content_length-1,path,ETag,output_file+'.dwnld')
                            os.rename(output_file+'.dwnld',output_file)
                            os.remove(output_file+'.dwnld.head')

                    else:
                        if new_header_content["Last-Modified"] != date_modified:
                            print "Your file has been modified, starting new download"
                            new_download()
                        else:
                            resume_connect(dest,port,file_size,total_content_length-1,path,date_modified,output_file+'.dwnld')
                            os.rename(output_file+'.dwnld',output_file)
                            os.remove(output_file+'.dwnld.head')

                else:
                    print "Your file cannot be resume. Start new downloading"
                    new_download()
            except:
                print "Connection error"
        else:
            print "File already existed"





# Organize input-command line
if len(sys.argv) == 4:
    output_file = sys.argv[2]
    dest_in = sys.argv[3]
    basic_download()
elif len(sys.argv) == 5:
    output_file = sys.argv[2]
    option_c = True
    dest_in = sys.argv[4]
    multi_download(numConn)
elif len(sys.argv) == 6:
    output_file = sys.argv[2]
    option_c = True
    numConn = sys.argv[4]
    dest_in = sys.argv[5]

