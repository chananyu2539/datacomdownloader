#!/usr/bin/env python

import urlparse
import os
import sys
import socket as c_sock



output_file = None
option_c = False
numConn = 5
dest_in = None
path = '/'
port = 80

# Organize input-command line
if len(sys.argv) == 4:
    output_file = sys.argv[2]
    dest_in = sys.argv[3]
elif len(sys.argv) == 5:
    output_file = sys.argv[2]
    option_c = True
    dest_in = sys.argv[4]
elif len(sys.argv) == 6:
    output_file = sys.argv[2]
    option_c = True
    numConn = sys.argv[4]
    dest_in = sys.argv[5]

# Organize address and port for connection
def setAddress(addIn):
    fullAddress = urlparse.urlparse(addIn)
    if (fullAddress.netloc).find(":") != -1:
        dest = fullAddress.netloc[:(fullAddress.netloc).find(":")]
    else:
        dest = fullAddress.netloc
    if fullAddress.port != None:
        port = fullAddress.port
    else:
        port = 80
    path = fullAddress.path

    return fullAddress,dest,port,path


def getSize(fileobject):
    with open(fileobject,'rb') as f:
        f.seek(0,2)        # move the cursor to the end of the file
        return f.tell()
    
def getHeadRequest(serv, objName):
    return ("HEAD {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n\r\n").format(o=objName, s=serv)


def getHeadRangeRequest(serv,objName,start_pos,end_pos,tag):
    return ("HEAD {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n"+
        "If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)   

def mkDownloadRequest(serv, objName):
    return ("GET {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n\r\n").format(o=objName, s=serv)

def mkResumReqModified(serv,objName,start_pos,end_pos,tag):
    return ("GET {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n"+
        "If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)
    

def split_header(out_file):
    header_dict = dict()
    with open(out_file,'rb') as h:
        all_data = h.read()        
    header_list = all_data.split("\r\n")
    for each in header_list[1:-2]:
        current_element = each.split(": ")
        header_dict[current_element[0]] = current_element[1]
    return header_dict    

def get_head_range(servName,portIn,reqHead,output_head):
    head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
    head_sock.connect((servName,portIn))

    head_sock.send(reqHead)
    data = ""

    while True:
        current = head_sock.recv(1024000)
        data+=current
        if data[-4:] == "\r\n\r\n":
            
            head_sock.close()
            break


    return sys.getsizeof(data)

def get_head(servName,portIn,reqHead,output_head):
    head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)

    head_sock.connect((servName,portIn))

    head_sock.send(reqHead)
    data = ""
    with open(output_head,'wb') as h:
        while True:
            current = head_sock.recv(1024000)
            h.write(current)
            data+=current
            if data[-4:] == "\r\n\r\n":    
                head_sock.close()
                break
    return sys.getsizeof(data)

def resume_connect(servName,portIn,start_byte,end_byte,path,version_reference,output_file):
    # get size of head in this request
    reqHead = getHeadRangeRequest(servName,path,start_byte,end_byte,version_reference)
    head_range_length = get_head_range(servName,portIn,reqHead,output_file+'.head')


    reqResume = mkResumReqModified(servName,path,start_byte,end_byte,version_reference)
    # make socket connection
    sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
    sock.connect((servName,portIn))
    sock.send(reqResume)
    with open(output_file,'rb') as rf:
        data_stream = rf.read()
    head = ""
    with open('temp','wb') as f:

        while True:
            head = sock.recv(1024)
            data_stream+=head
            f.write(head)
            if('\r\n\r\n' in data_stream):
                break

    with open('temp','rb') as rf:
        data = rf.read()
    os.remove('temp')
    with open(output_file,'ab') as f:
        f.write(data[data.find("\r\n\r\n")+4:])
        while True:
            current = sock.recv(1024000)
            f.write(current)
            data_stream+=current
            if sys.getsizeof(data_stream) == end_byte+1+head_range_length:
                sock.close()
                break




def connect(servName,portIn,startByte,path,output_file):

    # get content length from header
    reqHead = getHeadRequest(servName,path)
    header_length = get_head(servName,portIn,reqHead,output_file+'.head')
    header_content = split_header(output_file+".head")

    content_length = long(header_content['Content-Length'])

    request = mkDownloadRequest(servName,path)
    sock = c_sock.socket(c_sock.AF_INET, c_sock.SOCK_STREAM)
    sock.connect((servName,portIn))



    sock.send(request)
    data = ""
    with open(output_file,'wb') as f:

        while True:
            current = sock.recv(1024)
            f.write(current)
            data += current
            if('\r\n\r\n' in data):
                break
    with open(output_file,'rb') as rf:
        data = rf.read()
    
    with open(output_file,'wb') as f:
        f.write(data[data.find("\r\n\r\n")+4:])

        while True:
            current = sock.recv(1024000)
            f.write(current)
            data += current
            if sys.getsizeof(data) == content_length + header_length:
                sock.close()
                break
            
def new_download():
    addr,dest,port,path = setAddress(dest_in)
    # Check the scheme
    if addr.scheme == 'http':
        connect(dest,port,0,path,output_file+'.dwnld')
        os.rename(output_file+'.dwnld',output_file)
        os.remove(output_file+'.dwnld.head')
    else:
        print "Wrong format"


if (not (os.path.exists(output_file))) and (not (os.path.exists(output_file+'.dwnld'))):
    try:
        new_download() 
    except:
        print "Connection error"   
else:
    if not (os.path.exists(output_file)):
        try:
            addr,dest,port,path = setAddress(dest_in)
            is_ETag = False
            is_Date = False
            header_dict = split_header(output_file+".dwnld.head")
            total_content_length = int(header_dict["Content-Length"])


            try:
                ETag = header_dict["ETag"]
                is_ETag = True
            
            except:
                try:
                    date_modified = header_dict["Last-Modified"]
                    is_Date = True
                except:
                    is_Date = False

            if is_ETag or is_Date:
                file_size = getSize(output_file+".dwnld")
                # check that modified or not
                head_req = getHeadRequest(dest,path)
                get_head(dest,port,head_req,output_file+'_new.head')
                new_header_content = split_header(output_file+"_new.head")
                os.remove(output_file+"_new.head")
                if is_ETag:
                    if new_header_content["ETag"] != ETag:
                        print "Your file has been modified, starting new download"
                        new_download()
                    
                    else:
                        resume_connect(dest,port,file_size,total_content_length-1,path,ETag,output_file+'.dwnld')
                        os.rename(output_file+'.dwnld',output_file)
                        os.remove(output_file+'.dwnld.head')

                else:
                    if new_header_content["Last-Modified"] != date_modified:
                        print "Your file has been modified, starting new download"
                        new_download()
                    else:
                        resume_connect(dest,port,file_size,total_content_length-1,path,date_modified,output_file+'.dwnld')
                        os.rename(output_file+'.dwnld',output_file)
                        os.remove(output_file+'.dwnld.head')

            else:
                print "Your file cannot be resume. Start new downloading"
                new_download()
        except:
            print "Connection error"
    else:
        print "File already existed"
