#!/usr/bin/env python

import urlparse
import os
import sys
import socket as c_sock

output_file = None
option_c = False
numConn = 5
dest = None
path = '/'
port = 80

# Organize input-command line
if len(sys.argv) == 4:
	output_file = sys.argv[2]
	dest = sys.argv[3]
elif len(sys.argv) == 5:
	output_file = sys.argv[2]
	option_c = True
	dest = sys.argv[4]
elif len(sys.argv) == 6:
	output_file = sys.argv[2]
	option_c = True
	numConn = sys.argv[4]
	dest = sys.argv[5]

# Organize address and port for connection
def setAddress(addIn):
	fullAddress = urlparse.urlparse(addIn)
	if (fullAddress.netloc).find(":") != -1:
		dest = fullAddress.netloc[:(fullAddress.netloc).find(":")]
	else:
		dest = fullAddress.netloc
	if fullAddress.port != None:
		port = fullAddress.port
	else:
		port = 80
	path = fullAddress.path

	return fullAddress,dest,port,path


def getSize(fileobject):
    fileobject.seek(0,2) 		# move the cursor to the end of the file
    return fileobject.tell()
    
def getHeadRequest(serv, objName):
	return ("HEAD {o} HTTP/1.1\r\n"+"Host: {s}\r\n\r\n").format(o=objName, s=serv)

def mkDownloadRequest(serv, objName):
	return ("GET {o} HTTP/1.1\r\n"+"Host: {s}\r\n\r\n").format(o=objName, s=serv)

def mkResumeRequest(serv, objName, start_pos, end_pos):
	return ("GET {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + "Range: bytes={sp}-{ep}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos)

def mkResumReqModified(serv,objName,start_pos,end_pos,tag):
	return ("GET {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + "Range: bytes={sp}-{ep}\r\n"+"If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)

def deleteHeader(file,headLength):
	f= open(file,"rb")
	data = f.read()
	f.close()
	f = open(file,'wb')
	f.write(data[headLength:])
	f.close()



def connect(servName,portIn,startByte,path):
	print servName
	saveHeader = open(output_file+"_Header.txt",'wb')
	complete = False
	sock = c_sock.socket(c_sock.AF_INET, c_sock.SOCK_STREAM)
	head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
	head_sock.connect((servName, portIn))
	sock.connect((servName,portIn))
	# get content length from header
	reqHead = getHeadRequest(servName,path)
	head_sock.send(reqHead)
	head = head_sock.recv(1024)
	saveHeader.write(head)
	start = head.find('Content-Length')+16
	headLength =  len(head)
	contentLength = float(head[start:start+head[start:].find('\r\n')])
	
	sock.close
	#print head,"head"
	print contentLength,"content"
	request = mkResumeRequest(servName,path,0,contentLength-1)

	sock.send(request)
	f=open(output_file,'wb')
	while True:
		data = sock.recv(100)
		print data + '---------------------------------'
		if len(data) == 0:
			sock.close()

			if getSize(f) == contentLength + headLength:
				complete = True
			break
		f.write(data)
	return headLength
	
if not (os.path.exists(output_file)):
	addr,dest,port,path = setAddress(dest)
	print dest,port
	# Check the scheme
	if addr.scheme == 'http':
		head_len = connect(dest,port,0,path)
		deleteHeader(output_file,head_len)
	else:
		print "Wrong format"
else:
	
	h=open(output_file+"_Header.txt","rb")
	head = h.read()
	start_i = head.find('Content-Length')+16
	totalLength = float(head[start_i:start_i+head[start_i:].find('\r\n')])
	start_etag = head.find('ETag: ')+7
	ETag= head[start_etag:start_etag+head[start_etag:].find('\r\n')-1]
	print ETag