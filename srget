#!/usr/bin/env python

import urlparse
import os
import sys
import socket as c_sock

output_file = None
option_c = False
numConn = 5
dest = None
path = '/'
port = 80

# Organize input-command line
if len(sys.argv) == 4:
    output_file = sys.argv[2]
    dest = sys.argv[3]
elif len(sys.argv) == 5:
    output_file = sys.argv[2]
    option_c = True
    dest = sys.argv[4]
elif len(sys.argv) == 6:
    output_file = sys.argv[2]
    option_c = True
    numConn = sys.argv[4]
    dest = sys.argv[5]

# Organize address and port for connection
def setAddress(addIn):
    fullAddress = urlparse.urlparse(addIn)
    if (fullAddress.netloc).find(":") != -1:
        dest = fullAddress.netloc[:(fullAddress.netloc).find(":")]
    else:
        dest = fullAddress.netloc
    if fullAddress.port != None:
        port = fullAddress.port
    else:
        port = 80
    path = fullAddress.path

    return fullAddress,dest,port,path


def getSize(fileobject):
    with open(fileobject,'rb') as f:
        f.seek(0,2)        # move the cursor to the end of the file
        return f.tell()
    
def getHeadRequest(serv, objName):
    return ("HEAD {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n\r\n").format(o=objName, s=serv)

def getHeadRangeOnlyRequest(serv,objName,start_pos,end_pos):
    return ("HEAD {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos)  

def getHeadRangeRequest(serv,objName,start_pos,end_pos,tag):
    return ("HEAD {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n"+
        "If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)   

def mkDownloadRequest(serv, objName):
    return ("GET {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n\r\n").format(o=objName, s=serv)

def mkResumeRequest(serv, objName, start_pos, end_pos):
    return ("GET {o} HTTP/1.1\r\n"+
        "Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos)

def mkResumReqModified(serv,objName,start_pos,end_pos,tag):
    return ("GET {o} HTTP/1.1\r\n"+"Host: {s}\r\n" + 
        "Range: bytes={sp}-{ep}\r\n"+
        "If-Range: {t}\r\n\r\n").format(o=objName, s=serv,sp=start_pos,ep=end_pos,t=tag)

def deleteHeader(file):
    with open(file,'rb') as f:
        data = f.read()
    with open(file,'wb') as f:
        f.write(data[data.find("\r\n\r\n")+4:])
    
def append_new_content(data_string,exist_file):
    data_string = data_string[data_string.find("\r\n\r\n")+4:]
    with open(exist_file,'rb') as f:
        exist_data = f.read()
    with open(exist_file,'wb') as f:
        f.write(exist_data+data_string)


def split_header(out_file):
    header_dict = dict()
    with open(out_file,'rb') as h:
        all_data = h.read()        
    header_list = all_data.split("\r\n")
    for each in header_list[1:-2]:
        current_element = each.split(": ")
        header_dict[current_element[0]] = current_element[1]
    return header_dict    

def get_head_range(servName,portIn,reqHead,output_head):
    head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
    print servName,portIn
    head_sock.connect((servName,portIn))

    head_sock.send(reqHead)
    data = ""

    while True:
        current = head_sock.recv(1024000)
        data+=current
        if data[-4:] == "\r\n\r\n":
            
            head_sock.close()
            break

    return sys.getsizeof(data)

def get_head(servName,portIn,reqHead,output_head):
    head_sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)

    print servName,portIn
    head_sock.connect((servName,portIn))

    head_sock.send(reqHead)
    data = ""
    with open(output_head,'wb') as h:
        while True:
            current = head_sock.recv(1024000)
            h.write(current)
            data+=current
            if data[-4:] == "\r\n\r\n":    
                head_sock.close()
                break
    return sys.getsizeof(data)

def resume_connect(servName,portIn,start_byte,end_byte,path,version_reference,output_file):
    # get size of head in this request
    reqHead = getHeadRangeRequest(servName,path,start_byte,end_byte,version_reference)
    head_range_length = get_head_range(servName,portIn,reqHead,output_file+'.head')


    reqResume = mkResumReqModified(servName,path,start_byte,end_byte,version_reference)
    # make socket connection
    sock = c_sock.socket(c_sock.AF_INET,c_sock.SOCK_STREAM)
    print servName
    sock.connect((servName,portIn))
    sock.send(reqResume)
    with open(output_file,'rb') as rf:
        data_stream = rf.read()
    head = ""
    with open('temp','wb') as f:

        print '======================'

        while True:
            head = sock.recv(1024)
            data_stream+=head
            f.write(head)
            if('\r\n\r\n' in data_stream):
                break

    with open('temp','rb') as rf:
        data = rf.read()
    os.remove('temp')
    with open(output_file,'ab') as f:
        f.write(data[data.find("\r\n\r\n")+4:])
        while True:
            current = sock.recv(1024000)
            f.write(current)
            data_stream+=current

            if sys.getsizeof(data_stream) == end_byte+1+head_range_length:
                sock.close()
                break




def connect(servName,portIn,startByte,path):

    # get content length from header
    reqHead = getHeadRequest(servName,path)
    header_length = get_head(servName,portIn,reqHead,output_file+'.head')
    header_content = split_header(output_file+".head")
    content_length = int(header_content['Content-Length'])


    request = mkDownloadRequest(servName,path)
    print request
    sock = c_sock.socket(c_sock.AF_INET, c_sock.SOCK_STREAM)
    print servName,portIn
    sock.connect((servName,portIn))



    sock.send(request)
    data = ""
    with open(output_file,'wb') as f:

        while True:
            current = sock.recv(1024)
            f.write(current)
            data += current
            print data
            if('\r\n\r\n' in data):
                break
    with open(output_file,'rb') as rf:
        data = rf.read()

    
    with open(output_file,'wb') as f:
        f.write(data[data.find("\r\n\r\n")+4:])
        print data, getSize(output_file)
        while True:
            current = sock.recv(1024000)
            f.write(current)
            data += current
            print sys.getsizeof(data) ,content_length, header_length
            if sys.getsizeof(data) == content_length + header_length:
                sock.close()
                break
            
    
if not (os.path.exists(output_file)):
    addr,dest,port,path = setAddress(dest)
    print dest,port
    # Check the scheme
    if addr.scheme == 'http':
        connect(dest,port,0,path)
        print getSize(output_file)
    else:
        print "Wrong format"
    
else:
    addr,dest,port,path = setAddress(dest)
    is_ETag = False
    is_Date = False
    header_dict = split_header(output_file+".head")
    total_content_length = int(header_dict["Content-Length"])
    try:
        ETag = header_dict["ETag"]
        is_ETag = True
    
    except:
        try:
            date_modified = header_dict["Last-Modified"]
            is_Date = True
        except:
            is_Date = False

    if is_ETag or is_Date:
        file_size = getSize(output_file)
        print file_size,total_content_length
        if(total_content_length != file_size):
            if is_ETag:
                resume_connect(dest,port,file_size,total_content_length-1,path,ETag,output_file)

            else:
                resume_connect(dest,port,file_size,total_content_length-1,path,date_modified,output_file)
        else:
            print "File already existed"
    else:
        print "Your file cannot be resume. Start new downloading"
        addr,dest,port,path = setAddress(dest)
        print dest,port
        # Check the scheme
        if addr.scheme == 'http':
            connect(dest,port,0,path)
            print getSize(output_file)
        else:
            print "Wrong format"

